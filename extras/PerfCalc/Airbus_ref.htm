<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Takeoff Speed Calculator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 16px; background:#f4f6f8; color:#111; }
    .card { background:#fff; border:1px solid #ddd; padding:12px; margin-bottom:12px; max-width:980px; }
    label { display:block; margin:6px 0; }
    input, select { padding:6px; margin-left:8px; width:140px; }
    #banners .error-banner { background:#ffe6e6; color:#900; padding:8px; margin:6px 0; border-radius:4px; }
    #banners .caution-banner { background:#fff4e5; color:#8a5a00; padding:8px; margin:6px 0; border-radius:4px; }
    #banners .ok-banner { background:#e6ffed; color:#0a6b2f; padding:8px; margin:6px 0; border-radius:4px; }
    #result { background:#fff; border:1px solid #e0e0e0; padding:10px; margin-top:8px; border-radius:4px; }
    .inline { display:inline-block; vertical-align:middle; margin-right:12px; }
    .small { width:80px; }
    button { padding:8px 12px; margin-top:8px; }
    pre { background:#f7f7f7; padding:8px; border-radius:4px; overflow:auto; }
  </style>
</head>
<body>
  <div class="card">
    <h3>Takeoff Speed Calculator</h3>

    <label>Aircraft Type
      <select id="aircraftType">
        <option value="A320">A320</option>
		<option value="A321">A321</option>
		<option value="A330">A330</option>
      </select>
    </label>

    <label>Flaps Configuration
      <select id="cfg">
        <option value="1+F">1+F</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
    </label>

    <label>Runway Condition
      <select id="condition">
        <option value="dry">Dry</option>
        <option value="contaminated">Contaminated</option>
      </select>
    </label>

	<label>Weight
  <input id="weight" type="number" value="68" step="0.1" />
  <select id="weightUnit">
    <option value="t">Tonnes</option>
    <option value="lb">x1000 pounds</option>
  </select>
</label>	

    <label>CG 
      <input id="cg" type="number" value="28" step="0.1" /> (%MAC)
    </label>

<label>Runway length
  <input id="rw" type="number" value="3000" step="1" />
  <select id="rwUnit">
    <option value="m">metres</option>
    <option value="ft">feet</option>
  </select>
</label>

    <label>Wind component (+ headwind)
      <input id="windComp" type="number" value="0" step="1" /> kt
    </label>

    <label>Temperature / Assumed temp °C (leave blank to auto-suggest)
      <input id="temp" type="number" value="" step="1" class="small" />
    </label>

    <label style="margin-top:8px;">
      Use FLEX?
      <span class="inline"><label style="margin-left:8px;"><input type="radio" name="useFlex" id="useFlexYes" value="yes" checked> Yes</label></span>
      <span class="inline"><label style="margin-left:8px;"><input type="radio" name="useFlex" id="useFlexNo" value="no"> No (TOGA)</label></span>
      <button id="togaQuick" type="button" style="margin-left:12px;">TOGA only</button>
    </label>

    <label style="display:block; margin-top:6px;">
      <input id="autoFlex" type="checkbox" checked /> Auto-suggest FLEX (if Yes)
    </label>

    <div>
      <button id="calcButton">Calculate</button>
      <button id="resetButton" type="button">Reset</button>
    </div>

    <div id="banners" style="margin-top:10px"></div>
    <div id="result" style="display:none"></div>
  </div>

  <script>
  // ---------- AIRCRAFT DATA (original sample) ----------
  const AIRCRAFT = {
    "A330": {
      WEIGHT_RANGE: [121, 242],
      DATA: {
        "1+F": { temps:[-20,0,58], runways:[3000,4000], values:{
            "-20":{ "3000":"160/161/166", "4000":"160/171/175" },
            "0":  { "3000":"156/157/162", "4000":"153/166/171" },
            "58": { "3000":"143/143/147", "4000":"167/167/170" }
          }
        },
        "2": { temps:[-20,0,58], runways:[2500,3000], values:{
            "-20":{ "2500":"150/151/156", "3000":"154/156/160" },
            "0":  { "2500":"148/150/154", "3000":"152/154/158" },
            "58": { "2500":"140/142/146", "3000":"146/148/151" }
          }
        },
        "3": { temps:[-20,0,58], runways:[2000,3000], values:{
            "-20":{ "2000":"145/147/150", "3000":"150/152/155" },
            "0":  { "2000":"143/145/148", "3000":"148/150/153" },
            "58": { "2000":"136/138/141", "3000":"142/144/147" }
          }
        }
      },
      TRIM_ANCHORS: [
        { cg: 15, trim: 7.0 },
        { cg: 21, trim: 7.0 },
        { cg: 24, trim: 5.5 },
        { cg: 26, trim: 4.0 },
        { cg: 32, trim: 1.5 },
        { cg: 35, trim: 0.0 },
        { cg: 41, trim: 0.0 }
      ],
      MIN_V2_SEALEVEL: {
        "1+F": {"130":117,"140":121,"150":125,"160":130,"170":134,"180":137,"190":141,"200":145,"210":149,"220":152,"230":155,"240":159},
        "2":   {"130":128,"140":128,"150":128,"160":128,"170":130,"180":133,"190":137,"200":140,"210":144,"220":147},
        "3":   {"130":129,"140":129,"150":129,"160":129,"170":129,"180":129,"190":132,"200":135,"210":139,"220":142}
      },
      WIND_TABLE: {2000:9,2250:10,2500:11,2750:12,3000:12,3250:13,3500:13,3750:14,4000:14},
      V1_CORRECTION: -2,
      FLEX_LIMITS: {
        "30": 231.2,
        "34": 226.4,
        "40": 218.5,
        "44": 212.2,
        "50": 202,
        "58": 189.6
      }
    },
    "A321": {
      WEIGHT_RANGE: [48, 93],
      DATA: {
        "1+F": { temps:[0,70], runways:[2000,2500,3000], values:{
            "0":  { "2000":"137/137/146", "2500":"141/143/148", "3000":"148/155/160"},
            "70": { "2000":"125/125/130", "2500":"135/135/140", "3000":"145/145/150"}
          }
        },
        "2":   { temps:[0,70], runways:[2000,2500,3000], values:{
            "0":  { "2000":"135/136/141", "2500":"151/153/158", "3000":"160/162/167"},
            "70": { "2000":"123/124/127", "2500":"135/135/140", "3000":"146/148/151"}
          }
        },
        "3":   { temps:[0,70], runways:[2000,2500,3000], values:{
            "0":  { "2000":"137/138/143", "2500":"153/155/159", "3000":"160/162/165"},
            "70": { "2000":"124/127/131", "2500":"136/137/140", "3000":"146/146/148"}
          }
        }
      },
      TRIM_ANCHORS: [
        { cg: 12, trim: 4.5 },
        { cg: 15, trim: 3.75 },
		{ cg: 20, trim: 2.1 },
        { cg: 25, trim: 0.9 },
		{ cg: 30, trim: -0.5 },
        { cg: 35, trim: -1.9 },
        { cg: 41, trim: -3.5 }
      ],
      MIN_V2_SEALEVEL: {
        "1+F": { "35": 123, "40": 123, "45": 123, "50": 123, "55": 123, "60": 128, "65": 133, "70": 137, "75": 142, "80": 147},
        "2":   { "35": 123, "40": 123, "45": 123, "50": 123, "55": 123, "60": 123, "65": 126, "70": 131, "75": 136, "80": 140},
        "3":   { "35": 123, "40": 123, "45": 123, "50": 123, "55": 123, "60": 123, "65": 128, "70": 132, "75": 137, "80": 137}
      },
      WIND_TABLE: {2000:9,2250:10,2500:11,2750:12,3000:12,3250:13,3500:13,3750:14,4000:14},
      V1_CORRECTION: -2,
      FLEX_LIMITS: {
        "30": 92,
        "35": 90,
        "40": 88,
        "45": 86,
        "50": 84,
        "55": 82,
        "60": 80,
        "65": 78,
        "70": 76,
        "75": 74
      }
    },
	"A320": {
      WEIGHT_RANGE: [43, 80],
      DATA: {
        "1+F": { temps:[0,70], runways:[2000,2500,3000], values:{
            "0":  { "2000":"137/137/146", "2500":"141/143/148", "3000":"148/155/160"},
            "70": { "2000":"125/125/130", "2500":"135/135/140", "3000":"145/145/150"}
          }
        },
        "2":   { temps:[0,70], runways:[2000,2500,3000], values:{
            "0":  { "2000":"135/136/141", "2500":"151/153/158", "3000":"160/162/167"},
            "70": { "2000":"123/124/127", "2500":"135/135/140", "3000":"146/148/151"}
          }
        },
        "3":   { temps:[0,70], runways:[2000,2500,3000], values:{
            "0":  { "2000":"137/138/143", "2500":"153/155/159", "3000":"160/162/165"},
            "70": { "2000":"124/127/131", "2500":"136/137/140", "3000":"146/146/148"}
          }
        }
      },
      TRIM_ANCHORS: [
        { cg: 10.5, trim: 2.5 },
        { cg: 17, trim: 2.5 },
        { cg: 25, trim: 0.5 },
        { cg: 30, trim: -0.5 },
        { cg: 35, trim: -1.2 },
        { cg: 40, trim: -2.5 },
        { cg: 43, trim: -2.5 }
      ],
      MIN_V2_SEALEVEL: {
        "1+F": { "35": 123, "40": 123, "45": 123, "50": 123, "55": 123, "60": 128, "65": 133, "70": 137, "75": 142, "80": 147},
        "2":   { "35": 123, "40": 123, "45": 123, "50": 123, "55": 123, "60": 123, "65": 126, "70": 131, "75": 136, "80": 140},
        "3":   { "35": 123, "40": 123, "45": 123, "50": 123, "55": 123, "60": 123, "65": 128, "70": 132, "75": 137, "80": 137}
      },
      WIND_TABLE: {2000:9,2250:10,2500:11,2750:12,3000:12,3250:13,3500:13,3750:14,4000:14},
      V1_CORRECTION: -2,
      FLEX_LIMITS: {
        "30": 78,
        "35": 76,
        "40": 74,
        "45": 72,
        "50": 70,
        "55": 68,
        "60": 66,
        "65": 64,
        "70": 62,
        "75": 60
      }
    }
  };
  
 let currentAircraft;
 
  // ---------- Utilities ----------
  function bracket(val, arr){
    if(!arr || arr.length === 0) return [null, null];
    const sorted = arr.slice().sort((a,b)=>a-b);
    if(val <= sorted[0]) return [sorted[0], sorted[0]];
    if(val >= sorted[sorted.length-1]) return [sorted[sorted.length-1], sorted[sorted.length-1]];
    for(let i=0;i<sorted.length-1;i++){
      if(val >= sorted[i] && val <= sorted[i+1]) return [sorted[i], sorted[i+1]];
    }
    return [sorted[0], sorted[0]];
  }

  function interpolate(x, x0, y0, x1, y1){
    if(x1 === x0) return y0;
    return y0 + (y1 - y0) * ((x - x0) / (x1 - x0));
  }

  function parseSpeeds(str){
    if(!str || typeof str !== "string") return [NaN, NaN, NaN];
    return str.split("/").map(v => parseFloat(v));
  }
	
	// --- Unit conversion helpers ---
function tonnesToPounds(t) { return t * (2204.62/1000); }   // 1 tonne = 2204.62 lb
function poundsToTonnes(lb) { return lb / (2204.62/1000); }

function metresToFeet(m) { return m * 3.28084; }     // 1 m = 3.28084 ft
function feetToMetres(ft) { return ft / 3.28084; }


  // ---------- Trim interpolation ----------
  function computeTrim(cg){
    const anchors = currentAircraft && currentAircraft.TRIM_ANCHORS;
    if(!anchors || anchors.length === 0) return null;
    const sorted = anchors.slice().sort((a,b) => a.cg - b.cg);
    const cgVals = sorted.map(a => a.cg);
    const trimVals = sorted.map(a => a.trim);
    if(cg <= cgVals[0]) return Number(trimVals[0]).toFixed(1);
    const lastIdx = cgVals.length - 1;
    if(cg >= cgVals[lastIdx]) return Number(trimVals[lastIdx]).toFixed(1);
    let lowIdx = 0;
    for(let i = 0; i < lastIdx; i++){
      if(cg >= cgVals[i] && cg <= cgVals[i+1]){
        lowIdx = i;
        break;
      }
    }
    const x0 = cgVals[lowIdx], x1 = cgVals[lowIdx+1];
    const y0 = trimVals[lowIdx], y1 = trimVals[lowIdx+1];
    if(x1 === x0) return Number(y0).toFixed(1);
    const trim = y0 + (y1 - y0) * ((cg - x0) / (x1 - x0));
    return Number(trim).toFixed(1);
  }

  // ---------- Min V2 sea level ----------
  function getMinV2(cfg, weight){
    const table = currentAircraft.MIN_V2_SEALEVEL && currentAircraft.MIN_V2_SEALEVEL[cfg];
    if(!table) return { minV2: null };
    const keys = Object.keys(table).map(k=>Number(k)).sort((a,b)=>a-b);
    if(keys.length === 0) return { minV2: null };
    const [low, high] = bracket(weight, keys);
    const lowVal = Number(table[String(low)]);
    const highVal = Number(table[String(high)]);
    const minV2 = Math.round(interpolate(weight, low, lowVal, high, highVal));
    return { minV2 };
  }

  // ---------- Wind runway adjustment ----------
  function windRunwayAdjustment(runwayLength, windKnots){
    const table = currentAircraft.WIND_TABLE;
    if(!table) return 0;
    const keys = Object.keys(table).map(k=>Number(k)).sort((a,b)=>a-b);
    if(keys.length === 0) return 0;
    const [low, high] = bracket(runwayLength, keys);
    const lowVal = Number(table[String(low)]);
    const highVal = Number(table[String(high)]);
    const adjPerKnot = interpolate(runwayLength, low, lowVal, high, highVal);
    return windKnots * adjPerKnot;
  }

  // ---------- Output helpers ----------
  function outputBanners(bannersHtml){
    const bannersEl = document.getElementById("banners");
    if(bannersEl) bannersEl.innerHTML = bannersHtml || "";
  }

  function outputResultFlex({ type, cfg, rw, effectiveRunway, condition, weight, cg, V1, VR, V2, trim, minV2 }){
    const resultEl = document.getElementById("result");
    if(!resultEl) return;
    resultEl.style.display = "block";
    resultEl.innerHTML =
      '<strong>Aircraft:</strong> ' + type + '<br>' +
      '<strong>Config:</strong> ' + cfg + '<br>' +
      '<strong>Runway:</strong> ' + rw + ' m (effective ' + Math.round(effectiveRunway) + ' m)<br>' +
      '<strong>Condition:</strong> ' + condition + '<br>' +
      '<strong>Computed Speeds (FLEX):</strong> V1=' + V1 + ', VR=' + VR + ', V2=' + V2 + '<br>' +
      '<strong>Trim (UP):</strong> ' + trim + '<br>' +
      (minV2 != null ? ('<strong>Min V2 (sea level):</strong> ' + minV2 + ' kt') : '');
  }

  function outputResultToga({ type, cfg, rw, effectiveRunway, condition, weight, cg, V1, VR, V2, trim, minV2 }){
    const resultEl = document.getElementById("result");
    if(!resultEl) return;
    resultEl.style.display = "block";
    resultEl.innerHTML =
      '<strong>Aircraft:</strong> ' + type + '<br>' +
      '<strong>Config:</strong> ' + cfg + '<br>' +
      '<strong>Runway:</strong> ' + rw + ' m (effective ' + Math.round(effectiveRunway) + ' m)<br>' +
      '<strong>Condition:</strong> ' + condition + ' (treated as contaminated)<br>' +
      '<strong>Computed Speeds (TOGA):</strong> V1=' + V1 + ', VR=' + VR + ', V2=' + V2 + '<br>' +
      '<strong>Trim (UP):</strong> ' + trim + '<br>' +
      (minV2 != null ? ('<strong>Min V2 (sea level):</strong> ' + minV2 + ' kt') : '');
  }

  function hideResult(){
    const resultEl = document.getElementById("result");
    if(resultEl){
      resultEl.style.display = "none";
      resultEl.innerHTML = "";
    }
  }

  function setErrorBanner(message){
    const html = '<div class="error-banner">' + message + '</div>';
    outputBanners(html);
    hideResult();
  }

  function appendBanner(currentHtml, type, message){
    const classes = {
      error: 'error-banner',
      ok: 'ok-banner',
      caution: 'caution-banner'
    };
    const cls = classes[type] || 'caution-banner';
    return (currentHtml || '') + '<div class="' + cls + '">' + message + '</div>';
  }

  // ---------- FLEX weight limit helper ----------
  function isAssumedTempAllowedForWeight({ aircraft, cfg, assumedTemp, weight }){
    if(!aircraft || !aircraft.FLEX_LIMITS) return true;
    const cfgLimits = (aircraft.FLEX_LIMITS[cfg] ? aircraft.FLEX_LIMITS[cfg] : aircraft.FLEX_LIMITS);
    if(!cfgLimits) return true;
    const key = String(assumedTemp);
    if(cfgLimits[key] !== undefined) {
      return weight <= Number(cfgLimits[key]);
    }
    const anchors = Object.keys(cfgLimits).map(k => Number(k)).sort((a,b)=>a-b);
    if(anchors.length === 0) return true;
    const anchor = anchors.find(a => a >= assumedTemp);
    if(anchor !== undefined) return weight <= Number(cfgLimits[String(anchor)]);
    return false;
  }

  // ---------- suggestFlexTemp ----------
  function suggestFlexTemp({ cfg, rw, tempOAT, weight} = {}) {
    const step = 1;
    if (!currentAircraft || !currentAircraft.DATA || !currentAircraft.DATA[cfg]) return null;

    const cfgData = currentAircraft.DATA[cfg];
    const tempAnchors = Array.isArray(cfgData.temps) ? cfgData.temps.slice().sort((a,b)=>a-b) : [];
    if (tempAnchors.length === 0) return null;

    const maxAnchor = tempAnchors[tempAnchors.length - 1];
    const roundedOAT = Math.ceil((isNaN(tempOAT) ? 0 : tempOAT) / step) * step;
    const start = Math.max(roundedOAT, 30);
    const upperLimit = Math.min(maxAnchor, (isNaN(tempOAT) ? 0 : tempOAT) + 75);

    if (start > upperLimit) return null;

	for (let assumedTemp = upperLimit; assumedTemp >= start; assumedTemp -= step) {
        if (!isAssumedTempAllowedForWeight({ aircraft: currentAircraft, cfg, assumedTemp, weight })) continue;
        const speeds = computeSpeedsForAssumed({ cfg, rw, assumedTemp, currentAircraft });
        if (!speeds || speeds.some(v => isNaN(v))) continue;
        const V2 = Math.round(speeds[2]);
        const minV2Res = getMinV2(cfg, weight);
        if (minV2Res.minV2 !== null && V2 < minV2Res.minV2) continue;
        return assumedTemp;
      }
    return null;
  }

  // ---------- compute speeds helpers ----------
  function computeSpeedsForDisplay({ cfg, rw, tempProvided, temp, currentAircraft }){
    const runwayKey = String(rw);
    const cfgData = currentAircraft && currentAircraft.DATA && currentAircraft.DATA[cfg];
    if(!cfgData) return null;

    if(tempProvided){
      const tKey = String(Math.round(temp));
      if(cfgData.values && cfgData.values[tKey] && cfgData.values[tKey][runwayKey]) {
        return parseSpeeds(cfgData.values[tKey][runwayKey]).map(v => Math.round(v));
      }
      const temps = cfgData.temps || [];
      const runways = cfgData.runways || [];
      if(temps.length >= 2 && runways.length >= 1){
        const [tLow, tHigh] = bracket(temp, temps);
        const [rLow, rHigh] = bracket(rw, runways);
        const corner = (tK, rK) => {
          if(cfgData.values[tK] && cfgData.values[tK][rK]) return parseSpeeds(cfgData.values[tK][rK]);
          return null;
        };
        const s00 = corner(String(tLow), String(rLow));
        const s01 = corner(String(tLow), String(rHigh));
        const s10 = corner(String(tHigh), String(rLow));
        const s11 = corner(String(tHigh), String(rHigh));
        if(s00 && s01 && s10 && s11){
          const interpAlongRunway = (sLow, sHigh) => {
            const v1 = interpolate(rw, rLow, sLow[0], rHigh, sHigh[0]);
            const v2 = interpolate(rw, rLow, sLow[1], rHigh, sHigh[1]);
            const v3 = interpolate(rw, rLow, sLow[2], rHigh, sHigh[2]);
            return [v1, v2, v3];
          };
          const speedsAtTlow = interpAlongRunway(s00, s01);
          const speedsAtThigh = interpAlongRunway(s10, s11);
          const V1 = interpolate(temp, tLow, speedsAtTlow[0], tHigh, speedsAtThigh[0]);
          const VR = interpolate(temp, tLow, speedsAtTlow[1], tHigh, speedsAtThigh[1]);
          const V2 = interpolate(temp, tLow, speedsAtTlow[2], tHigh, speedsAtThigh[2]);
          return [Math.round(V1), Math.round(VR), Math.round(V2)];
        }
      }
    }

    const temps = cfgData.temps || [];
    if(temps.length === 0) return null;
    const anchorSorted = temps.slice().sort((a,b)=>a-b);
    let anchorTemp;
    if(tempProvided && !isNaN(temp)){
      const minA = anchorSorted[0], maxA = anchorSorted[anchorSorted.length-1];
      const clamped = Math.max(minA, Math.min(maxA, temp));
      anchorTemp = anchorSorted.reduce((best, t) => Math.abs(t - clamped) < Math.abs(best - clamped) ? t : best, anchorSorted[0]);
    } else {
      anchorTemp = anchorSorted[0];
    }

    const anchorKey = String(anchorTemp);
    if(cfgData.values && cfgData.values[anchorKey] && cfgData.values[anchorKey][runwayKey]){
      return parseSpeeds(cfgData.values[anchorKey][runwayKey]).map(v => Math.round(v));
    }

    const runways = cfgData.runways || [];
    if(temps.length >= 2 && runways.length >= 1){
      const [tLow, tHigh] = bracket(anchorTemp, temps);
      const [rLow, rHigh] = bracket(rw, runways);
      const corner = (tK, rK) => {
        if(cfgData.values[tK] && cfgData.values[tK][rK]) return parseSpeeds(cfgData.values[tK][rK]);
        return null;
      };
      const s00 = corner(String(tLow), String(rLow));
      const s01 = corner(String(tLow), String(rHigh));
      const s10 = corner(String(tHigh), String(rLow));
      const s11 = corner(String(tHigh), String(rHigh));
      if(s00 && s01 && s10 && s11){
        const interpAlongRunway = (sLow, sHigh) => {
          const v1 = interpolate(rw, rLow, sLow[0], rHigh, sHigh[0]);
          const v2 = interpolate(rw, rLow, sLow[1], rHigh, sHigh[1]);
          const v3 = interpolate(rw, rLow, sLow[2], rHigh, sHigh[2]);
          return [v1, v2, v3];
        };
        const speedsAtTlow = interpAlongRunway(s00, s01);
        const speedsAtThigh = interpAlongRunway(s10, s11);
        const V1 = interpolate(anchorTemp, tLow, speedsAtTlow[0], tHigh, speedsAtThigh[0]);
        const VR = interpolate(anchorTemp, tLow, speedsAtTlow[1], tHigh, speedsAtThigh[1]);
        const V2 = interpolate(anchorTemp, tLow, speedsAtTlow[2], tHigh, speedsAtThigh[2]);
        return [Math.round(V1), Math.round(VR), Math.round(V2)];
      }
    }

    return null;
  }

  function computeSpeedsForAssumed({ cfg, rw, assumedTemp, currentAircraft }){
    const runwayKey = String(rw);
    const cfgData = currentAircraft && currentAircraft.DATA && currentAircraft.DATA[cfg];
    if(!cfgData) return null;
    const tKey = String(assumedTemp);
    if(cfgData.values && cfgData.values[tKey] && cfgData.values[tKey][runwayKey]) return parseSpeeds(cfgData.values[tKey][runwayKey]);
    const temps = cfgData.temps || [];
    const runways = cfgData.runways || [];
    if(temps.length >= 2 && runways.length >= 1){
      const [tLow, tHigh] = bracket(assumedTemp, temps);
      const [rLow, rHigh] = bracket(rw, runways);
      const corner = (tK, rK) => {
        if(cfgData.values[tK] && cfgData.values[tK][rK]) return parseSpeeds(cfgData.values[tK][rK]);
        return null;
      };
      const s00 = corner(String(tLow), String(rLow));
      const s01 = corner(String(tLow), String(rHigh));
      const s10 = corner(String(tHigh), String(rLow));
      const s11 = corner(String(tHigh), String(rHigh));
      if(s00 && s01 && s10 && s11){
        const interpAlongRunway = (sLow, sHigh) => {
          const v1 = interpolate(rw, rLow, sLow[0], rHigh, sHigh[0]);
          const v2 = interpolate(rw, rLow, sLow[1], rHigh, sHigh[1]);
          const v3 = interpolate(rw, rLow, sLow[2], rHigh, sHigh[2]);
          return [v1, v2, v3];
        };
        const speedsAtTlow = interpAlongRunway(s00, s01);
        const speedsAtThigh = interpAlongRunway(s10, s11);
        const V1 = interpolate(assumedTemp, tLow, speedsAtTlow[0], tHigh, speedsAtThigh[0]);
        const VR = interpolate(assumedTemp, tLow, speedsAtTlow[1], tHigh, speedsAtThigh[1]);
        const V2 = interpolate(assumedTemp, tLow, speedsAtTlow[2], tHigh, speedsAtThigh[2]);
        return [Math.round(V1), Math.round(VR), Math.round(V2)];
      }
    }
    return null;
  }

  // ---------- Main calculate ----------
function calculate(){
  const typeEl = document.getElementById("aircraftType");
  if(!typeEl){ setErrorBanner("Aircraft selector missing"); return; }
  const type = typeEl.value;
  currentAircraft = AIRCRAFT[type];
  if(!currentAircraft){ setErrorBanner("No data for aircraft " + type); return; }

  const cfg = (document.getElementById("cfg") || {}).value || "1+F";
  const condition = (document.getElementById("condition") || {}).value || "dry";

  // --- weight with unit conversion ---
  const weightInput = parseFloat((document.getElementById("weight") || {}).value);
  const weightUnit = (document.getElementById("weightUnit") || {}).value || "t";
  const weight = (weightUnit === "lb") ? (weightInput / (2204.62/1000)) : weightInput; // convert lb→t

  // --- runway with unit conversion ---
  const rwInput = parseFloat((document.getElementById("rw") || {}).value);
  const rwUnit = (document.getElementById("rwUnit") || {}).value || "m";
  const rw = (rwUnit === "ft") ? (rwInput / 3.28084) : rwInput; // convert ft→m

  const cg = parseFloat((document.getElementById("cg") || {}).value);
  const windComp = parseFloat((document.getElementById("windComp") || {}).value || 0);

  const useFlexYes = document.getElementById("useFlexYes");
  const useFlexNo = document.getElementById("useFlexNo");
  const useFlex = useFlexYes && useFlexYes.checked ? true : (useFlexNo && useFlexNo.checked ? false : true);

  const autoFlexEl = document.getElementById("autoFlex");
  const autoSuggest = autoFlexEl ? autoFlexEl.checked : true;

  const tempEl = document.getElementById("temp");
  const tempProvided = tempEl && String(tempEl.value).trim() !== "";
  const temp = tempProvided ? Number(tempEl.value) : NaN;

  if(isNaN(weight) || isNaN(cg) || isNaN(rw)){
    setErrorBanner("Please enter valid numeric values for weight, CG, and runway length.");
    return;
  }
  if(weight < currentAircraft.WEIGHT_RANGE[0] || weight > currentAircraft.WEIGHT_RANGE[1]){
    setErrorBanner("Weight " + weight + " t outside certified range for " + type + ".");
    return;
  }

  const windAdj = windRunwayAdjustment(rw, windComp);
  const effectiveRunway = rw + windAdj;
  let banners = "";
  banners = appendBanner(banners, "caution",
    "Wind " + windComp + " kt → runway adjusted by " + Math.round(windAdj) + " m → effective " + Math.round(effectiveRunway) + " m");

  const isContaminated = (condition !== "dry");
  if(isContaminated){
    banners = appendBanner(banners, "error",
      "Runway " + condition + " — FLEX not permitted. Using TOGA thrust.");
  }

  // FLEX vs TOGA logic (unchanged from your original)
  // ...
  // At the end, call outputResultFlex or outputResultToga with display units
  // (see below).
   if(isContaminated){
      banners = appendBanner(banners, "error", "Runway contaminated — FLEX not permitted. Using TOGA thrust.");
      const displaySpeeds = computeSpeedsForDisplay({ cfg, rw, tempProvided, temp, currentAircraft });
      if(!displaySpeeds){ setErrorBanner("No certified speeds available for TOGA display. Check inputs."); return; }
      let [V1, VR, V2] = displaySpeeds.map(v => Math.round(v));
      V1 = Math.max(V1 + currentAircraft.V1_CORRECTION, 0);
      const trim = computeTrim(cg);
      const minV2Res = getMinV2(cfg, weight);
      if(minV2Res.minV2 !== null){
        if(V2 >= minV2Res.minV2) banners = appendBanner(banners, "ok", "Computed V2 " + V2 + " ≥ min V2 " + minV2Res.minV2 + " — SAFE");
        else banners = appendBanner(banners, "error", "Computed V2 " + V2 + " < min V2 " + minV2Res.minV2 + " — NOT SAFE");
      }
      outputBanners(banners);
      outputResultToga({ type, cfg, rw, effectiveRunway, condition, weight, cg, V1, VR, V2, trim, minV2: minV2Res.minV2 });
      return;
    }

    // FLEX allowed and runway dry. Determine assumed temp:
    let chosenAssumedTemp = null;

    if(tempProvided && !isNaN(temp)){
      if(temp < 30){
        banners = appendBanner(banners, "caution", "OAT " + temp + "°C < 30°C (below flat-rating). FLEX candidates start at 30°C.");
        if(autoSuggest){
          const suggested = suggestFlexTemp({ cfg, rw, tempOAT: temp, weight });
          if(suggested !== null){
            chosenAssumedTemp = suggested;
            banners = appendBanner(banners, "ok", "Suggested FLEX temp: " + chosenAssumedTemp + " °C (tool suggestion)");
          } else {
            banners = appendBanner(banners, "caution", "No safe FLEX temp found within certified anchors or weight limits — use TOGA or reduce weight.");
          }
        } else {
          banners = appendBanner(banners, "caution", "Auto-suggest disabled — provide assumed temp ≥ 30°C or choose NO FLEX.");
        }
      } else {
        const candidate = Math.round(temp);
        if(!isAssumedTempAllowedForWeight({ aircraft: currentAircraft, cfg, assumedTemp: candidate, weight })){
          banners = appendBanner(banners, "error", "Provided assumed temp " + candidate + "°C exceeds certified max takeoff weight for that FLEX temp. Use TOGA or reduce weight.");
          outputBanners(banners);
          hideResult();
          return;
        }
        chosenAssumedTemp = candidate;
        banners = appendBanner(banners, "ok", "Using user OAT as assumed temp: " + chosenAssumedTemp + " °C (flat-rated region).");
      }
    } else {
      if(autoSuggest){
        const suggested = suggestFlexTemp({ cfg, rw, tempOAT: 0, weight });
        if(suggested !== null){
          chosenAssumedTemp = suggested;
          banners = appendBanner(banners, "ok", "Suggested FLEX temp: " + chosenAssumedTemp + " °C (tool suggestion)");
        } else {
          banners = appendBanner(banners, "caution", "No safe FLEX temp found within certified anchors or weight limits — use TOGA or reduce weight.");
        }
      } else {
        banners = appendBanner(banners, "caution", "Auto-suggest disabled — provide assumed temp ≥ 30°C or choose NO FLEX.");
      }
    }

    if(chosenAssumedTemp === null){
      outputBanners(banners);
      hideResult();
      return;
    }

    const displaySpeeds = computeSpeedsForAssumed({ cfg, rw, assumedTemp: chosenAssumedTemp, currentAircraft });
    if(!displaySpeeds){ setErrorBanner("No certified speeds available for assumed temp " + chosenAssumedTemp + "°C at " + rw + "m."); return; }

    let [V1, VR, V2] = displaySpeeds.map(v => Math.round(v));
    const trim = computeTrim(cg);
    const minV2Res = getMinV2(cfg, weight);
    if(minV2Res.minV2 !== null){
      if(V2 >= minV2Res.minV2) banners = appendBanner(banners, "ok", "Computed V2 " + V2 + " ≥ min V2 " + minV2Res.minV2 + " — SAFE");
      else banners = appendBanner(banners, "error", "Computed V2 " + V2 + " < min V2 " + minV2Res.minV2 + " — NOT SAFE");
    }
    outputBanners(banners);
    outputResultFlex({ type, cfg, rw, effectiveRunway, condition, weight, cg, V1, VR, V2, trim, minV2: minV2Res.minV2 });
	
}

  // ---------- UI wiring ----------
  document.getElementById("calcButton").addEventListener("click", calculate);
  document.getElementById("resetButton").addEventListener("click", function(){
    document.getElementById("weight").value = 68;
    document.getElementById("cg").value = 28;
    document.getElementById("rw").value = 3000;
    document.getElementById("windComp").value = 0;
    document.getElementById("temp").value = "";
    document.getElementById("banners").innerHTML = "";
    hideResult();
  });

  // quick TOGA button: set NO FLEX and calculate
  document.getElementById("togaQuick").addEventListener("click", function(){
    document.getElementById("useFlexNo").checked = true;
    calculate();
  });

  // initial hide
  hideResult();
  </script>
<footer style="margin-top:20px; font-size:2em; color:red; font-weight:bold; text-align:center;"> ⚠️ For simulation purposes only — not for real‑world Calculations</footer>
 </body>
 </html>